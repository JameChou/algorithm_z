# 选择排序

>[!note]
选择排序是最简单朴素的排序算法，但是时间复杂度较高，且不是稳定排序。其他基础排序算法都是基于选择排序优化。

其核心是找到数组中的最小值，然后把它和数组的第一个元素交换位置；接着再遍历一遍数组，找到第二小的元素，和数组的第二个元素交换位置；以此类推，直到整个数组有序。

```java
void sort(int[] nums) {
    int n = nums.length;

    // 需要排序的Index
    int sortedIndex = 0;

    while (sortedIndex < n) {
        int minIndex = sortedIndex;

        // 记录最小值，然后再做交换操作
        for (int i = sortedIndex + 1; i < n; i++) {
            if (nums[i] < nums[minIndex]) {
                minIndex = i;
            }
        }

        int temp = nums[minIndex];
        nums[minIndex] = nums[sortedIndex];
        nums[sortedIndex] = temp;

        sortedIndex++;
    }

}
```

## 是否为原地排序

这个是显而易见的，这是一个原地排序的算法，因为我们没有开辟出额外的数组来辅助进行排序，空间复杂度为$O(1)$。

## 时空复杂度分析
这个`sort` 函数中包含一个`while` 循环嵌套一个`for` 循环，相当于以下这样:
```java
for (int sortedIndex = 0; sortedIndex < n; sortedIndex++) {
    for (int i = sortedIndex + 1; i < n; i++) {
        // ...
    }
}
```

嵌套`for` 循环，总循环次数是$(n - 1) + (n - 2) + (n - 3) + .... + 1$，这是等差数列求和，结构近似于$n^2 / 2$，所以这个排序算法时间复杂度为$O(n^2)$，其中`n` 是待排序数组的元素个数。

**而且这个算法有一个特点，即使整个数组已经有序的，它还是会执行$n^2/2$次，即原始数据的有序度对算法时间复杂度没有任何影响。** 

>[!tip]

> 对于一般的算法时空复杂度分析，我们只需要从Big O表示法的角度来分析即可，即仅关心量级（最高次项）的大小，而不关心系数和低次项。
> 
> 但是在分析不同排序算法的场景下，实际执行次数，以及一些特殊情况（比如数组本身就有序的情况），还是有必要关注的。
> 
> 因为有多种排序算法从Big O的视角来看都是$O(n^2)$复杂度，那么我们要根据他们的实际执行次数以及特殊情况下的表现，来分析它们的优劣。




