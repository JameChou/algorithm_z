# 跳表实现原理简单实现

链表的增删改查的时间复杂度为$O(n)$，而数组要查询的时候为$O(1)$，链表需要使用指针一个一个向下去查找节点。

那么如何有更好的手段去快速的查找呢？

一种方式是借助键值映射，用$O(1)$的时间直接拿到目标节点，避免了遍历查找的时间消耗。

另一种方式，是使用跳表(Skip List)，利用空间换时间的思想，用额外的空间记录额外的信息，增删改查的时间复杂度都能优化到$O(\log_{}{N})$。

## 跳表的核心原理
```
indexLevel   0-----------------------8-----10
indexLevel   0-----------4-----------8-----10
indexLevel   0-----2-----4-----6-----8-----10
indexLevel   0--1--2--3--4--5--6--7--8--9--10
nodeLevel    a->b->c->d->e->f->g->h->i->j->k
```
跳表相当于在原链表的基础上，增加了多层索引，每向上一层，索引节点的数量减少一半，索引的间隔变为2倍，所以索引的高度是$\log_{}{N}$，$N$代表链表中元素的个数。

此时，如果我们想查询索引为7的元素，可以从最高层索引开始一层一层地往下找：

首先最高层的第一个索引敬意是`[0, 8]` ，可以确定索引7在这个区间内，所以从下一层的节点0开始搜索。

第二层从节点0开始，索引区间`[0, 4]` 不包含索引7，继续往右移动到节点4，索引区间`[4, 8]` 包含索引7，所以从下一层的节点4开始搜索；

第三层从节点4开始，索引区间`[4, 6]` 不包含索引7，继续往右移动到节点6，索引区间`[6, 8]` 包含索引7，所以从下一层的节点6开始搜索；

第四层从节点6开始，索引区间`[6, 7]` 包含索引7，最终找到目标节点`h` 。

这个搜索过程中，会经过$\log{}{N}$层索引，在每层索引中移动的次数不会超过2次（因为上层索引区间在下一层被分为两半），所以跳表的查询时间复杂度为$O(\log{}{N})$。

