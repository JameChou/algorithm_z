## 时间复杂度

[时间复杂度Wiki](https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)

衡量算法的优劣，有两种评估方式，事前估计和后期测试。
后期测试有性能测试、基准测试（BenchMark）等手段。

但是后期测试有以下限制:
* **测试结果非常依赖测试环境**: 如：不同机型、不同编译器版本、不同硬件都会影响测试结果。
* **测试结果受数据规模的影响很大**。 

所以需要一种方法，可以不受环境或数据规模的影响，粗略的估计算法的执行效率，这种方法就是复杂度分析。

### 时间复杂度分析
#### 大O表示法

假设问题的规模为n,则程序的时间复杂度表示为$T(n)$。**代码的执行时间$T(n)$与每行代码的执行次数$n$成正比**。

###  常数操作
跟数据量无关的，是一个固定时间的东西 **常数操作**。

跟数据量有关的，就是 **非常数操作**

例子:
因为在内存中，这是一个连续的区域开辟出来的，所以可以直接从地址就可以把这个数据取出来。

```java
int a = arr[i];
```

而像链表这种数据结构的，是跟数据量有关的，必须从上一个指针才可以找到下一个，找到某个值是跟数据量有关的。

```java
List<String> s = new LinkedList<String>();

// 这里就是非常数操作
s.get(5);
```

### 什么时间复杂度
> 在计算机科学中，算法的时间复杂度（time complexity）是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大 $O$ 符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。例如，如果一个算法对于任何大小为 $n$ （必须比 $n^{0}$ 大）的输入，它至多需要 $5n^{3} + 3n$ 的时间运行完毕，那么它的渐近时间复杂度是 $O(n^{3}$)。

以选择排序为例:
```java
    private static void selectSort(int[] array) {
        // 外面循环N次
        for (int i = 0; i < array.length; i++) {
            int min = array[i];

            int swapIndex = i;
            // 这里可以近似看成也是循环N次
            for (int j = i + 1; j < array.length; j++) {
                if (array[j] < min) {
                    min = array[j];
                    swapIndex = j;
                }
            }

            // 进行一次交换
            if (swapIndex != i) {
                int temp = array[i];
                array[i] = array[swapIndex];
                array[swapIndex] = temp;
            }
        }
    }
```


对于多少次常量操作可以写成下面的表达式：

**看（遍历）**: $N + (N - 1) + (N - 2) + (N - 3) + .... + 1$

**比（遍历）**: $N + (N - 1) + (N - 2) + (N - 3) + .... + 1$

**swap(交换)**: $N$

那么总共用了多少次常量操作呢?

$aN^{2} + bN + c$

**对于这样的表达式来讲，我们只保留最大的值，并且忽略系数写作$O(N^{2})$**

**也就是说什么是时间复杂度表达式即：常量操作数量的表达式**

**大O或Big O**表示的是这个算法表示时间复杂度最大上限。小数据量是没有太大区别。

为什么要忽略系数呢，以$O(N^{2})$和$O(N)$来讲，数据量小的情况基本一样的，当数据量起来之后，第一种方法瓶颈就在于$N^{2}$上，所以其他的小系数就可以忽略了。只记录瓶颈在哪里。

评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。

下面的这个例子进行说明，指标可能估计不出来实际的算法优劣:
```java

public static void process1() {
    int N = 1000;
    int a = 0;
    for (int i = 0; i < N; i++) {
        a = 2 + 5;
        a = 4 * 7;
        a = 6 * 8;
    }
}

public static void process2() {
    int N = 1000;
    int a = 0;
    for (int i = 0; i < N; i++) {
        a = 2 | 5;
        a = 4 & 7;
        a = 6 ^ 8;
    }
}
```

这两个函数都是$O(N)$的时间复杂度操作，每次循环只进行3次常量操作。那么这种指标就无法估计出算法的优劣，这时候就需要实际去跑一跑代码进行测试，来比较两种算法的优劣程度。

### 对数器

对数器的概念和使用
1. 有一个你想要测的方法a
2. 实现复杂度不好但是容易实现的方法b
3. 实现一个随机样本产生器
4. 把方法a和方法b跑相同的随机样本，看看得到的结果是否一样。
5. 如果有一个随机样本使得对比结果不一致，打印样本进行人工干预，改对方法a或者方法b
6. 当样本数量很多时对比测试依然正确，可以确定方法a已经正确



